{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n}; // src/index.ts\n\n\nimport * as React2 from \"react\";\nimport { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from \"use-sync-external-store/with-selector.js\"; // src/utils/react.ts\n\nimport * as ReactOriginal from \"react\";\nvar React = // prettier-ignore\n// @ts-ignore\n\"default\" in ReactOriginal ? ReactOriginal[\"default\"] : ReactOriginal; // src/components/Context.ts\n\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis :\n/* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\n\nfunction getContext() {\n  var _a;\n\n  if (!React.createContext) return {};\n  const contextMap = (_a = gT[ContextKey]) != null ? _a : gT[ContextKey] = /* @__PURE__ */new Map();\n  let realContext = contextMap.get(React.createContext);\n\n  if (!realContext) {\n    realContext = React.createContext(null);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      realContext.displayName = \"ReactRedux\";\n    }\n\n    contextMap.set(React.createContext, realContext);\n  }\n\n  return realContext;\n}\n\nvar ReactReduxContext = /* @__PURE__ */getContext(); // src/utils/useSyncExternalStore.ts\n\nvar notInitialized = () => {\n  throw new Error(\"uSES not initialized!\");\n}; // src/hooks/useReduxContext.ts\n\n\nfunction createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext2() {\n    const contextValue = React.useContext(context);\n\n    if (process.env.NODE_ENV !== \"production\" && !contextValue) {\n      throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n    }\n\n    return contextValue;\n  };\n}\n\nvar useReduxContext = /* @__PURE__ */createReduxContextHook(); // src/hooks/useSelector.ts\n\nvar useSyncExternalStoreWithSelector = notInitialized;\n\nvar initializeUseSelector = fn => {\n  useSyncExternalStoreWithSelector = fn;\n};\n\nvar refEquality = (a, b) => a === b;\n\nfunction createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  return function useSelector2(selector, equalityFnOrOptions = {}) {\n    const {\n      equalityFn = refEquality,\n      devModeChecks = {}\n    } = typeof equalityFnOrOptions === \"function\" ? {\n      equalityFn: equalityFnOrOptions\n    } : equalityFnOrOptions;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n\n      if (typeof selector !== \"function\") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(`You must pass a function as an equality function to useSelector`);\n      }\n    }\n\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck,\n      identityFunctionCheck\n    } = useReduxContext2();\n    const firstRun = React.useRef(true);\n    const wrappedSelector = React.useCallback({\n      [selector.name](state) {\n        const selected = selector(state);\n\n        if (process.env.NODE_ENV !== \"production\") {\n          const {\n            identityFunctionCheck: finalIdentityFunctionCheck,\n            stabilityCheck: finalStabilityCheck\n          } = __spreadValues({\n            stabilityCheck,\n            identityFunctionCheck\n          }, devModeChecks);\n\n          if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n            const toCompare = selector(state);\n\n            if (!equalityFn(selected, toCompare)) {\n              let stack = void 0;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                state,\n                selected,\n                selected2: toCompare,\n                stack\n              });\n            }\n          }\n\n          if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n            if (selected === state) {\n              let stack = void 0;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                stack\n              });\n            }\n          }\n\n          if (firstRun.current) firstRun.current = false;\n        }\n\n        return selected;\n      }\n\n    }[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n}\n\nvar useSelector = /* @__PURE__ */createSelectorHook(); // src/utils/react-is.ts\n\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\n\nfunction isValidElementType(type) {\n  if (typeof type === \"string\" || typeof type === \"function\") {\n    return true;\n  }\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n    return true;\n  }\n\n  if (typeof type === \"object\" && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    const $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        {\n          const type = object.type;\n\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n              return type;\n\n            default:\n              {\n                const $$typeofType = type && type.$$typeof;\n\n                switch ($$typeofType) {\n                  case REACT_SERVER_CONTEXT_TYPE:\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n\n                  default:\n                    return $$typeof;\n                }\n              }\n          }\n        }\n\n      case REACT_PORTAL_TYPE:\n        {\n          return $$typeof;\n        }\n    }\n  }\n\n  return void 0;\n}\n\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\n\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n} // src/utils/warning.ts\n\n\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (e) {}\n} // src/connect/verifySubselectors.ts\n\n\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n    }\n  }\n}\n\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n} // src/connect/selectorFactory.ts\n\n\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\n\nfunction finalPropsSelectorFactory(dispatch, _a) {\n  var _b = _a,\n      {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps\n  } = _b,\n      options = __objRest(_b, [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]);\n\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n} // src/utils/bindActionCreators.ts\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n\n  return boundActionCreators;\n} // src/utils/isPlainObject.ts\n\n\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) return false;\n  let proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n\n  return proto === baseProto;\n} // src/utils/verifyPlainObject.ts\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n  }\n} // src/connect/wrapMapToProps.ts\n\n\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, {\n    displayName\n  }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (process.env.NODE_ENV !== \"production\") verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n\n    return proxy;\n  };\n} // src/connect/invalidArgFactory.ts\n\n\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n  };\n} // src/connect/mapDispatchToProps.ts\n\n\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(dispatch => // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n} // src/connect/mapStateToProps.ts\n\n\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n} // src/connect/mergeProps.ts\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return __spreadValues(__spreadValues(__spreadValues({}, ownProps), stateProps), dispatchProps);\n}\n\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, {\n    displayName,\n    areMergedPropsEqual\n  }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (process.env.NODE_ENV !== \"production\") verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n\n      return mergedProps;\n    };\n  };\n}\n\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n} // src/utils/batch.ts\n\n\nfunction defaultNoopBatch(callback) {\n  callback();\n} // src/utils/Subscription.ts\n\n\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      let listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nvar nullListeners = {\n  notify() {},\n\n  get: () => []\n};\n\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++;\n\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n} // src/utils/useIsomorphicLayoutEffect.ts\n\n\nvar canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect; // src/utils/shallowEqual.ts\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n} // src/utils/hoistStatics.ts\n\n\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\n\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n\n    let keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n} // src/components/connect.tsx\n\n\nvar useSyncExternalStore = notInitialized;\n\nvar initializeConnect = fn => {\n  useSyncExternalStore = fn;\n};\n\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\n\nvar stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return () => {};\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n\n    if (!error) {\n      lastThrownError = null;\n    }\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n\n  return unsubscribeWrapper;\n}\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nvar hasWarnedAboutDeprecatedPureOption = false;\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n\n  const wrapWithConnect = WrappedComponent => {\n    if (process.env.NODE_ENV !== \"production\") {\n      const isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n    }\n\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        const _a = props,\n              {\n          reactReduxForwardedRef: reactReduxForwardedRef2\n        } = _a,\n              wrapperProps2 = __objRest(_a, [\"reactReduxForwardedRef\"]);\n\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        let ResultContext = Context;\n\n        if (propsContext == null ? void 0 : propsContext.Consumer) {\n          if (process.env.NODE_ENV !== \"production\") {\n            const isValid = /* @__PURE__ */isContextConsumer( // @ts-ignore\n\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n\n            if (!isValid) {\n              throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n            }\n\n            ResultContext = propsContext;\n          }\n        }\n\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = React.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n\n      if (process.env.NODE_ENV !== \"production\" && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n      }\n\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n\n        return __spreadProps(__spreadValues({}, contextValue), {\n          subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = React.useRef();\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef();\n      const renderIsScheduled = React.useRef(false);\n      const isProcessingDispatch = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef();\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n\n      try {\n        actualChildProps = useSyncExternalStore( // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n\n        throw err;\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (// @ts-ignore\n\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, __spreadProps(__spreadValues({}, actualChildProps), {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n\n    const _Connect = React.memo(ConnectFunction);\n\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, __spreadProps(__spreadValues({}, props), {\n          reactReduxForwardedRef: ref\n        }));\n      });\n\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n\n  return wrapWithConnect;\n}\n\nvar connect_default = connect; // src/components/Provider.tsx\n\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = \"once\",\n  identityFunctionCheck = \"once\"\n}) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0,\n      stabilityCheck,\n      identityFunctionCheck\n    };\n  }, [store, serverState, stabilityCheck, identityFunctionCheck]);\n  const previousState = React.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nvar Provider_default = Provider; // src/hooks/useStore.ts\n\nfunction createStoreHook(context = ReactReduxContext) {\n  const useReduxContext2 = // @ts-ignore\n  context === ReactReduxContext ? useReduxContext : // @ts-ignore\n  createReduxContextHook(context);\n  return function useStore2() {\n    const {\n      store\n    } = useReduxContext2();\n    return store;\n  };\n}\n\nvar useStore = /* @__PURE__ */createStoreHook(); // src/hooks/useDispatch.ts\n\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore2 = // @ts-ignore\n  context === ReactReduxContext ? useStore : createStoreHook(context);\n  return function useDispatch2() {\n    const store = useStore2();\n    return store.dispatch;\n  };\n}\n\nvar useDispatch = /* @__PURE__ */createDispatchHook(); // src/exports.ts\n\nvar batch = defaultNoopBatch; // src/index.ts\n\ninitializeUseSelector(useSyncExternalStoreWithSelector2);\ninitializeConnect(React2.useSyncExternalStore);\nexport { Provider_default as Provider, ReactReduxContext, batch, connect_default as connect, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual, useDispatch, useSelector, useStore };","map":{"version":3,"sources":["../src/index.ts","../src/utils/react.ts","../src/components/Context.ts","../src/utils/useSyncExternalStore.ts","../src/hooks/useReduxContext.ts","../src/hooks/useSelector.ts","../src/utils/react-is.ts","../src/utils/warning.ts","../src/connect/verifySubselectors.ts","../src/connect/selectorFactory.ts","../src/utils/bindActionCreators.ts","../src/utils/isPlainObject.ts","../src/utils/verifyPlainObject.ts","../src/connect/wrapMapToProps.ts","../src/connect/invalidArgFactory.ts","../src/connect/mapDispatchToProps.ts","../src/connect/mapStateToProps.ts","../src/connect/mergeProps.ts","../src/utils/batch.ts","../src/utils/Subscription.ts","../src/utils/useIsomorphicLayoutEffect.ts","../src/utils/shallowEqual.ts","../src/utils/hoistStatics.ts","../src/components/connect.tsx","../src/components/Provider.tsx","../src/hooks/useStore.ts","../src/hooks/useDispatch.ts","../src/exports.ts"],"names":["React","useSyncExternalStoreWithSelector","useReduxContext","useSelector","wrapperProps","reactReduxForwardedRef","subscription","notifyNestedSubs","useStore","useDispatch"],"mappings":"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","sourcesContent":["// The primary entry point assumes we are working with React 18, and thus have\r\n// useSyncExternalStore available. We can import that directly from React itself.\r\n// The useSyncExternalStoreWithSelector has to be imported, but we can use the\r\n// non-shim version. This shaves off the byte size of the shim.\r\n\r\nimport * as React from 'react'\r\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\r\n\r\nimport { initializeUseSelector } from './hooks/useSelector'\r\nimport { initializeConnect } from './components/connect'\r\n\r\ninitializeUseSelector(useSyncExternalStoreWithSelector)\r\ninitializeConnect(React.useSyncExternalStore)\r\n\r\nexport * from './exports'\r\n","import * as ReactOriginal from 'react'\r\nimport type * as ReactNamespace from 'react'\r\n\r\nexport const React: typeof ReactNamespace =\r\n  // prettier-ignore\r\n  // @ts-ignore\r\n  'default' in ReactOriginal ? ReactOriginal['default'] : ReactOriginal as any\r\n","import type { Context } from 'react'\r\nimport { React } from '../utils/react'\r\nimport type { Action, Store, UnknownAction } from 'redux'\r\nimport type { Subscription } from '../utils/Subscription'\r\nimport type { ProviderProps } from './Provider'\r\n\r\nexport interface ReactReduxContextValue<\r\n  SS = any,\r\n  A extends Action<string> = UnknownAction\r\n> extends Pick<ProviderProps, 'stabilityCheck' | 'identityFunctionCheck'> {\r\n  store: Store<SS, A>\r\n  subscription: Subscription\r\n  getServerState?: () => SS\r\n}\r\n\r\nconst ContextKey = Symbol.for(`react-redux-context`)\r\nconst gT: {\r\n  [ContextKey]?: Map<\r\n    typeof React.createContext,\r\n    Context<ReactReduxContextValue | null>\r\n  >\r\n} = (\r\n  typeof globalThis !== 'undefined'\r\n    ? globalThis\r\n    : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {}\r\n) as any\r\n\r\nfunction getContext(): Context<ReactReduxContextValue | null> {\r\n  if (!React.createContext) return {} as any\r\n\r\n  const contextMap = (gT[ContextKey] ??= new Map<\r\n    typeof React.createContext,\r\n    Context<ReactReduxContextValue | null>\r\n  >())\r\n  let realContext = contextMap.get(React.createContext)\r\n  if (!realContext) {\r\n    realContext = React.createContext<ReactReduxContextValue | null>(\r\n      null as any\r\n    )\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      realContext.displayName = 'ReactRedux'\r\n    }\r\n    contextMap.set(React.createContext, realContext)\r\n  }\r\n  return realContext\r\n}\r\n\r\nexport const ReactReduxContext = /*#__PURE__*/ getContext()\r\n\r\nexport type ReactReduxContextInstance = typeof ReactReduxContext\r\n\r\nexport default ReactReduxContext\r\n","import type { useSyncExternalStore } from 'use-sync-external-store'\r\nimport type { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector'\r\n\r\nexport const notInitialized = () => {\r\n  throw new Error('uSES not initialized!')\r\n}\r\n\r\nexport type uSES = typeof useSyncExternalStore\r\nexport type uSESWS = typeof useSyncExternalStoreWithSelector\r\n","import { React } from '../utils/react'\r\nimport { ReactReduxContext } from '../components/Context'\r\nimport type { ReactReduxContextValue } from '../components/Context'\r\n\r\n/**\r\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\r\n */\r\nexport function createReduxContextHook(context = ReactReduxContext) {\r\n  return function useReduxContext(): ReactReduxContextValue {\r\n    const contextValue = React.useContext(context)\r\n\r\n    if (process.env.NODE_ENV !== 'production' && !contextValue) {\r\n      throw new Error(\r\n        'could not find react-redux context value; please ensure the component is wrapped in a <Provider>'\r\n      )\r\n    }\r\n\r\n    return contextValue!\r\n  }\r\n}\r\n\r\n/**\r\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @returns {any} the value of the `ReactReduxContext`\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useReduxContext } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const { store } = useReduxContext()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\r\nexport const useReduxContext = /*#__PURE__*/ createReduxContextHook()\r\n","//import * as React from 'react'\r\nimport { React } from '../utils/react'\r\n\r\nimport type { ReactReduxContextValue } from '../components/Context'\r\nimport { ReactReduxContext } from '../components/Context'\r\nimport type { EqualityFn, NoInfer } from '../types'\r\nimport type { uSESWS } from '../utils/useSyncExternalStore'\r\nimport { notInitialized } from '../utils/useSyncExternalStore'\r\nimport {\r\n  createReduxContextHook,\r\n  useReduxContext as useDefaultReduxContext,\r\n} from './useReduxContext'\r\n\r\n/**\r\n * The frequency of development mode checks.\r\n *\r\n * @since 8.1.0\r\n * @internal\r\n */\r\nexport type DevModeCheckFrequency = 'never' | 'once' | 'always'\r\n\r\n/**\r\n * Represents the configuration for development mode checks.\r\n *\r\n * @since 9.0.0\r\n * @internal\r\n */\r\nexport interface DevModeChecks {\r\n  /**\r\n   * Overrides the global stability check for the selector.\r\n   * - `once` - Run only the first time the selector is called.\r\n   * - `always` - Run every time the selector is called.\r\n   * - `never` - Never run the stability check.\r\n   *\r\n   * @default 'once'\r\n   *\r\n   * @since 8.1.0\r\n   */\r\n  stabilityCheck: DevModeCheckFrequency\r\n\r\n  /**\r\n   * Overrides the global identity function check for the selector.\r\n   * - `once` - Run only the first time the selector is called.\r\n   * - `always` - Run every time the selector is called.\r\n   * - `never` - Never run the identity function check.\r\n   *\r\n   * **Note**: Previously referred to as `noopCheck`.\r\n   *\r\n   * @default 'once'\r\n   *\r\n   * @since 9.0.0\r\n   */\r\n  identityFunctionCheck: DevModeCheckFrequency\r\n}\r\n\r\nexport interface UseSelectorOptions<Selected = unknown> {\r\n  equalityFn?: EqualityFn<Selected>\r\n\r\n  /**\r\n   * `useSelector` performs additional checks in development mode to help\r\n   * identify and warn about potential issues in selector behavior. This\r\n   * option allows you to customize the behavior of these checks per selector.\r\n   *\r\n   * @since 9.0.0\r\n   */\r\n  devModeChecks?: Partial<DevModeChecks>\r\n}\r\n\r\nexport interface UseSelector {\r\n  <TState = unknown, Selected = unknown>(\r\n    selector: (state: TState) => Selected,\r\n    equalityFn?: EqualityFn<Selected>\r\n  ): Selected\r\n  <TState = unknown, Selected = unknown>(\r\n    selector: (state: TState) => Selected,\r\n    options?: UseSelectorOptions<Selected>\r\n  ): Selected\r\n}\r\n\r\nlet useSyncExternalStoreWithSelector = notInitialized as uSESWS\r\nexport const initializeUseSelector = (fn: uSESWS) => {\r\n  useSyncExternalStoreWithSelector = fn\r\n}\r\n\r\nconst refEquality: EqualityFn<any> = (a, b) => a === b\r\n\r\n/**\r\n * Hook factory, which creates a `useSelector` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useSelector` hook bound to the specified context.\r\n */\r\nexport function createSelectorHook(\r\n  context: React.Context<ReactReduxContextValue<\r\n    any,\r\n    any\r\n  > | null> = ReactReduxContext\r\n): UseSelector {\r\n  const useReduxContext =\r\n    context === ReactReduxContext\r\n      ? useDefaultReduxContext\r\n      : createReduxContextHook(context)\r\n\r\n  return function useSelector<TState, Selected extends unknown>(\r\n    selector: (state: TState) => Selected,\r\n    equalityFnOrOptions:\r\n      | EqualityFn<NoInfer<Selected>>\r\n      | UseSelectorOptions<NoInfer<Selected>> = {}\r\n  ): Selected {\r\n    const { equalityFn = refEquality, devModeChecks = {} } =\r\n      typeof equalityFnOrOptions === 'function'\r\n        ? { equalityFn: equalityFnOrOptions }\r\n        : equalityFnOrOptions\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (!selector) {\r\n        throw new Error(`You must pass a selector to useSelector`)\r\n      }\r\n      if (typeof selector !== 'function') {\r\n        throw new Error(`You must pass a function as a selector to useSelector`)\r\n      }\r\n      if (typeof equalityFn !== 'function') {\r\n        throw new Error(\r\n          `You must pass a function as an equality function to useSelector`\r\n        )\r\n      }\r\n    }\r\n\r\n    const {\r\n      store,\r\n      subscription,\r\n      getServerState,\r\n      stabilityCheck,\r\n      identityFunctionCheck,\r\n    } = useReduxContext()\r\n\r\n    const firstRun = React.useRef(true)\r\n\r\n    const wrappedSelector = React.useCallback<typeof selector>(\r\n      {\r\n        [selector.name](state: TState) {\r\n          const selected = selector(state)\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            const {\r\n              identityFunctionCheck: finalIdentityFunctionCheck,\r\n              stabilityCheck: finalStabilityCheck,\r\n            } = {\r\n              stabilityCheck,\r\n              identityFunctionCheck,\r\n              ...devModeChecks,\r\n            }\r\n            if (\r\n              finalStabilityCheck === 'always' ||\r\n              (finalStabilityCheck === 'once' && firstRun.current)\r\n            ) {\r\n              const toCompare = selector(state)\r\n              if (!equalityFn(selected, toCompare)) {\r\n                let stack: string | undefined = undefined\r\n                try {\r\n                  throw new Error()\r\n                } catch (e) {\r\n                  ;({ stack } = e as Error)\r\n                }\r\n                console.warn(\r\n                  'Selector ' +\r\n                    (selector.name || 'unknown') +\r\n                    ' returned a different result when called with the same parameters. This can lead to unnecessary rerenders.' +\r\n                    '\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization',\r\n                  {\r\n                    state,\r\n                    selected,\r\n                    selected2: toCompare,\r\n                    stack,\r\n                  }\r\n                )\r\n              }\r\n            }\r\n            if (\r\n              finalIdentityFunctionCheck === 'always' ||\r\n              (finalIdentityFunctionCheck === 'once' && firstRun.current)\r\n            ) {\r\n              // @ts-ignore\r\n              if (selected === state) {\r\n                let stack: string | undefined = undefined\r\n                try {\r\n                  throw new Error()\r\n                } catch (e) {\r\n                  ;({ stack } = e as Error)\r\n                }\r\n                console.warn(\r\n                  'Selector ' +\r\n                    (selector.name || 'unknown') +\r\n                    ' returned the root state when called. This can lead to unnecessary rerenders.' +\r\n                    '\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.',\r\n                  { stack }\r\n                )\r\n              }\r\n            }\r\n            if (firstRun.current) firstRun.current = false\r\n          }\r\n          return selected\r\n        },\r\n      }[selector.name],\r\n      [selector, stabilityCheck, devModeChecks.stabilityCheck]\r\n    )\r\n\r\n    const selectedState = useSyncExternalStoreWithSelector(\r\n      subscription.addNestedSub,\r\n      store.getState,\r\n      getServerState || store.getState,\r\n      wrappedSelector,\r\n      equalityFn\r\n    )\r\n\r\n    React.useDebugValue(selectedState)\r\n\r\n    return selectedState\r\n  }\r\n}\r\n\r\n/**\r\n * A hook to access the redux store's state. This hook takes a selector function\r\n * as an argument. The selector is called with the store state.\r\n *\r\n * This hook takes an optional equality comparison function as the second parameter\r\n * that allows you to customize the way the selected state is compared to determine\r\n * whether the component needs to be re-rendered.\r\n *\r\n * @param {Function} selector the selector function\r\n * @param {Function=} equalityFn the function that will be used to determine equality\r\n *\r\n * @returns {any} the selected state\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useSelector } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const counter = useSelector(state => state.counter)\r\n *   return <div>{counter}</div>\r\n * }\r\n */\r\nexport const useSelector = /*#__PURE__*/ createSelectorHook()\r\n","import type { ElementType, MemoExoticComponent, ReactElement } from 'react'\r\n\r\n// Directly ported from:\r\n// https://unpkg.com/browse/react-is@18.3.0-canary-ee68446ff-20231115/cjs/react-is.production.js\r\n// It's very possible this could change in the future, but given that\r\n// we only use these in `connect`, this is a low priority.\r\n\r\nconst REACT_ELEMENT_TYPE = Symbol.for('react.element')\r\nconst REACT_PORTAL_TYPE = Symbol.for('react.portal')\r\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')\r\nconst REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')\r\nconst REACT_PROFILER_TYPE = Symbol.for('react.profiler')\r\nconst REACT_PROVIDER_TYPE = Symbol.for('react.provider')\r\nconst REACT_CONTEXT_TYPE = Symbol.for('react.context')\r\nconst REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context')\r\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')\r\nconst REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')\r\nconst REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')\r\nconst REACT_MEMO_TYPE = Symbol.for('react.memo')\r\nconst REACT_LAZY_TYPE = Symbol.for('react.lazy')\r\nconst REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')\r\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference')\r\n\r\nexport const ForwardRef = REACT_FORWARD_REF_TYPE\r\nexport const Memo = REACT_MEMO_TYPE\r\n\r\nexport function isValidElementType(type: any): type is ElementType {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n  if (\r\n    type === REACT_FRAGMENT_TYPE ||\r\n    type === REACT_PROFILER_TYPE ||\r\n    type === REACT_STRICT_MODE_TYPE ||\r\n    type === REACT_SUSPENSE_TYPE ||\r\n    type === REACT_SUSPENSE_LIST_TYPE ||\r\n    type === REACT_OFFSCREEN_TYPE\r\n  ) {\r\n    return true\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (\r\n      type.$$typeof === REACT_LAZY_TYPE ||\r\n      type.$$typeof === REACT_MEMO_TYPE ||\r\n      type.$$typeof === REACT_PROVIDER_TYPE ||\r\n      type.$$typeof === REACT_CONTEXT_TYPE ||\r\n      type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n      // types supported by any Flight configuration anywhere since\r\n      // we don't know which Flight build this will end up being used\r\n      // with.\r\n      type.$$typeof === REACT_CLIENT_REFERENCE ||\r\n      type.getModuleId !== undefined\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfunction typeOf(object: any): symbol | undefined {\r\n  if (typeof object === 'object' && object !== null) {\r\n    const $$typeof = object.$$typeof\r\n\r\n    switch ($$typeof) {\r\n      case REACT_ELEMENT_TYPE: {\r\n        const type = object.type\r\n\r\n        switch (type) {\r\n          case REACT_FRAGMENT_TYPE:\r\n          case REACT_PROFILER_TYPE:\r\n          case REACT_STRICT_MODE_TYPE:\r\n          case REACT_SUSPENSE_TYPE:\r\n          case REACT_SUSPENSE_LIST_TYPE:\r\n            return type\r\n\r\n          default: {\r\n            const $$typeofType = type && type.$$typeof\r\n\r\n            switch ($$typeofType) {\r\n              case REACT_SERVER_CONTEXT_TYPE:\r\n              case REACT_CONTEXT_TYPE:\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_LAZY_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n              case REACT_PROVIDER_TYPE:\r\n                return $$typeofType\r\n\r\n              default:\r\n                return $$typeof\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      case REACT_PORTAL_TYPE: {\r\n        return $$typeof\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport function isContextConsumer(object: any): object is ReactElement {\r\n  return typeOf(object) === REACT_CONTEXT_TYPE\r\n}\r\n\r\nexport function isMemo(object: any): object is MemoExoticComponent<any> {\r\n  return typeOf(object) === REACT_MEMO_TYPE\r\n}\r\n","/**\r\n * Prints a warning in the console if it exists.\r\n *\r\n * @param {String} message The warning message.\r\n * @returns {void}\r\n */\r\nexport default function warning(message: string) {\r\n  /* eslint-disable no-console */\r\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n    console.error(message)\r\n  }\r\n  /* eslint-enable no-console */\r\n  try {\r\n    // This error was thrown as a convenience so that if you enable\r\n    // \"break on all exceptions\" in your console,\r\n    // it would pause the execution at this line.\r\n    throw new Error(message)\r\n    /* eslint-disable no-empty */\r\n  } catch (e) {}\r\n  /* eslint-enable no-empty */\r\n}\r\n","import warning from '../utils/warning'\r\n\r\nfunction verify(selector: unknown, methodName: string): void {\r\n  if (!selector) {\r\n    throw new Error(`Unexpected value for ${methodName} in connect.`)\r\n  } else if (\r\n    methodName === 'mapStateToProps' ||\r\n    methodName === 'mapDispatchToProps'\r\n  ) {\r\n    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {\r\n      warning(\r\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nexport default function verifySubselectors(\r\n  mapStateToProps: unknown,\r\n  mapDispatchToProps: unknown,\r\n  mergeProps: unknown\r\n): void {\r\n  verify(mapStateToProps, 'mapStateToProps')\r\n  verify(mapDispatchToProps, 'mapDispatchToProps')\r\n  verify(mergeProps, 'mergeProps')\r\n}\r\n","import type { Dispatch, Action } from 'redux'\r\nimport type { ComponentType } from 'react'\r\nimport verifySubselectors from './verifySubselectors'\r\nimport type { EqualityFn, ExtendedEqualityFn } from '../types'\r\n\r\nexport type SelectorFactory<S, TProps, TOwnProps, TFactoryOptions> = (\r\n  dispatch: Dispatch<Action<string>>,\r\n  factoryOptions: TFactoryOptions\r\n) => Selector<S, TProps, TOwnProps>\r\n\r\nexport type Selector<S, TProps, TOwnProps = null> = TOwnProps extends\r\n  | null\r\n  | undefined\r\n  ? (state: S) => TProps\r\n  : (state: S, ownProps: TOwnProps) => TProps\r\n\r\nexport type MapStateToProps<TStateProps, TOwnProps, State> = (\r\n  state: State,\r\n  ownProps: TOwnProps\r\n) => TStateProps\r\n\r\nexport type MapStateToPropsFactory<TStateProps, TOwnProps, State> = (\r\n  initialState: State,\r\n  ownProps: TOwnProps\r\n) => MapStateToProps<TStateProps, TOwnProps, State>\r\n\r\nexport type MapStateToPropsParam<TStateProps, TOwnProps, State> =\r\n  | MapStateToPropsFactory<TStateProps, TOwnProps, State>\r\n  | MapStateToProps<TStateProps, TOwnProps, State>\r\n  | null\r\n  | undefined\r\n\r\nexport type MapDispatchToPropsFunction<TDispatchProps, TOwnProps> = (\r\n  dispatch: Dispatch<Action<string>>,\r\n  ownProps: TOwnProps\r\n) => TDispatchProps\r\n\r\nexport type MapDispatchToProps<TDispatchProps, TOwnProps> =\r\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\r\n  | TDispatchProps\r\n\r\nexport type MapDispatchToPropsFactory<TDispatchProps, TOwnProps> = (\r\n  dispatch: Dispatch<Action<string>>,\r\n  ownProps: TOwnProps\r\n) => MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\r\n\r\nexport type MapDispatchToPropsParam<TDispatchProps, TOwnProps> =\r\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\r\n  | MapDispatchToProps<TDispatchProps, TOwnProps>\r\n\r\nexport type MapDispatchToPropsNonObject<TDispatchProps, TOwnProps> =\r\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\r\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\r\n\r\nexport type MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> = (\r\n  stateProps: TStateProps,\r\n  dispatchProps: TDispatchProps,\r\n  ownProps: TOwnProps\r\n) => TMergedProps\r\n\r\ninterface PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\r\n  readonly areStatesEqual: ExtendedEqualityFn<State, TOwnProps>\r\n  readonly areStatePropsEqual: EqualityFn<TStateProps>\r\n  readonly areOwnPropsEqual: EqualityFn<TOwnProps>\r\n}\r\n\r\nexport function pureFinalPropsSelectorFactory<\r\n  TStateProps,\r\n  TOwnProps,\r\n  TDispatchProps,\r\n  TMergedProps,\r\n  State\r\n>(\r\n  mapStateToProps: WrappedMapStateToProps<TStateProps, TOwnProps, State>,\r\n  mapDispatchToProps: WrappedMapDispatchToProps<TDispatchProps, TOwnProps>,\r\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\r\n  dispatch: Dispatch<Action<string>>,\r\n  {\r\n    areStatesEqual,\r\n    areOwnPropsEqual,\r\n    areStatePropsEqual,\r\n  }: PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State>\r\n) {\r\n  let hasRunAtLeastOnce = false\r\n  let state: State\r\n  let ownProps: TOwnProps\r\n  let stateProps: TStateProps\r\n  let dispatchProps: TDispatchProps\r\n  let mergedProps: TMergedProps\r\n\r\n  function handleFirstCall(firstState: State, firstOwnProps: TOwnProps) {\r\n    state = firstState\r\n    ownProps = firstOwnProps\r\n    stateProps = mapStateToProps(state, ownProps)\r\n    dispatchProps = mapDispatchToProps(dispatch, ownProps)\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\r\n    hasRunAtLeastOnce = true\r\n    return mergedProps\r\n  }\r\n\r\n  function handleNewPropsAndNewState() {\r\n    stateProps = mapStateToProps(state, ownProps)\r\n\r\n    if (mapDispatchToProps.dependsOnOwnProps)\r\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\r\n\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\r\n    return mergedProps\r\n  }\r\n\r\n  function handleNewProps() {\r\n    if (mapStateToProps.dependsOnOwnProps)\r\n      stateProps = mapStateToProps(state, ownProps)\r\n\r\n    if (mapDispatchToProps.dependsOnOwnProps)\r\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\r\n\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\r\n    return mergedProps\r\n  }\r\n\r\n  function handleNewState() {\r\n    const nextStateProps = mapStateToProps(state, ownProps)\r\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)\r\n    stateProps = nextStateProps\r\n\r\n    if (statePropsChanged)\r\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\r\n\r\n    return mergedProps\r\n  }\r\n\r\n  function handleSubsequentCalls(nextState: State, nextOwnProps: TOwnProps) {\r\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\r\n    const stateChanged = !areStatesEqual(\r\n      nextState,\r\n      state,\r\n      nextOwnProps,\r\n      ownProps\r\n    )\r\n    state = nextState\r\n    ownProps = nextOwnProps\r\n\r\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState()\r\n    if (propsChanged) return handleNewProps()\r\n    if (stateChanged) return handleNewState()\r\n    return mergedProps\r\n  }\r\n\r\n  return function pureFinalPropsSelector(\r\n    nextState: State,\r\n    nextOwnProps: TOwnProps\r\n  ) {\r\n    return hasRunAtLeastOnce\r\n      ? handleSubsequentCalls(nextState, nextOwnProps)\r\n      : handleFirstCall(nextState, nextOwnProps)\r\n  }\r\n}\r\n\r\ninterface WrappedMapStateToProps<TStateProps, TOwnProps, State> {\r\n  (state: State, ownProps: TOwnProps): TStateProps\r\n  readonly dependsOnOwnProps: boolean\r\n}\r\n\r\ninterface WrappedMapDispatchToProps<TDispatchProps, TOwnProps> {\r\n  (dispatch: Dispatch<Action<string>>, ownProps: TOwnProps): TDispatchProps\r\n  readonly dependsOnOwnProps: boolean\r\n}\r\n\r\nexport interface InitOptions<TStateProps, TOwnProps, TMergedProps, State>\r\n  extends PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\r\n  readonly shouldHandleStateChanges: boolean\r\n  readonly displayName: string\r\n  readonly wrappedComponentName: string\r\n  readonly WrappedComponent: ComponentType<TOwnProps>\r\n  readonly areMergedPropsEqual: EqualityFn<TMergedProps>\r\n}\r\n\r\nexport interface SelectorFactoryOptions<\r\n  TStateProps,\r\n  TOwnProps,\r\n  TDispatchProps,\r\n  TMergedProps,\r\n  State\r\n> extends InitOptions<TStateProps, TOwnProps, TMergedProps, State> {\r\n  readonly initMapStateToProps: (\r\n    dispatch: Dispatch<Action<string>>,\r\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\r\n  ) => WrappedMapStateToProps<TStateProps, TOwnProps, State>\r\n  readonly initMapDispatchToProps: (\r\n    dispatch: Dispatch<Action<string>>,\r\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\r\n  ) => WrappedMapDispatchToProps<TDispatchProps, TOwnProps>\r\n  readonly initMergeProps: (\r\n    dispatch: Dispatch<Action<string>>,\r\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>\r\n  ) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\r\n}\r\n\r\n// TODO: Add more comments\r\n\r\n// The selector returned by selectorFactory will memoize its results,\r\n// allowing connect's shouldComponentUpdate to return false if final\r\n// props have not changed.\r\n\r\nexport default function finalPropsSelectorFactory<\r\n  TStateProps,\r\n  TOwnProps,\r\n  TDispatchProps,\r\n  TMergedProps,\r\n  State\r\n>(\r\n  dispatch: Dispatch<Action<string>>,\r\n  {\r\n    initMapStateToProps,\r\n    initMapDispatchToProps,\r\n    initMergeProps,\r\n    ...options\r\n  }: SelectorFactoryOptions<\r\n    TStateProps,\r\n    TOwnProps,\r\n    TDispatchProps,\r\n    TMergedProps,\r\n    State\r\n  >\r\n) {\r\n  const mapStateToProps = initMapStateToProps(dispatch, options)\r\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)\r\n  const mergeProps = initMergeProps(dispatch, options)\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps)\r\n  }\r\n\r\n  return pureFinalPropsSelectorFactory<\r\n    TStateProps,\r\n    TOwnProps,\r\n    TDispatchProps,\r\n    TMergedProps,\r\n    State\r\n  >(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options)\r\n}\r\n","import type { ActionCreatorsMapObject, Dispatch } from 'redux'\r\n\r\nexport default function bindActionCreators(\r\n  actionCreators: ActionCreatorsMapObject,\r\n  dispatch: Dispatch\r\n): ActionCreatorsMapObject {\r\n  const boundActionCreators: ActionCreatorsMapObject = {}\r\n\r\n  for (const key in actionCreators) {\r\n    const actionCreator = actionCreators[key]\r\n    if (typeof actionCreator === 'function') {\r\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args))\r\n    }\r\n  }\r\n  return boundActionCreators\r\n}\r\n","/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\r\nexport default function isPlainObject(obj: unknown) {\r\n  if (typeof obj !== 'object' || obj === null) return false\r\n\r\n  let proto = Object.getPrototypeOf(obj)\r\n  if (proto === null) return true\r\n\r\n  let baseProto = proto\r\n  while (Object.getPrototypeOf(baseProto) !== null) {\r\n    baseProto = Object.getPrototypeOf(baseProto)\r\n  }\r\n\r\n  return proto === baseProto\r\n}\r\n","import isPlainObject from './isPlainObject'\r\nimport warning from './warning'\r\n\r\nexport default function verifyPlainObject(\r\n  value: unknown,\r\n  displayName: string,\r\n  methodName: string\r\n) {\r\n  if (!isPlainObject(value)) {\r\n    warning(\r\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`\r\n    )\r\n  }\r\n}\r\n","import type { ActionCreatorsMapObject, Dispatch, ActionCreator } from 'redux'\r\n\r\nimport type { FixTypeLater } from '../types'\r\nimport verifyPlainObject from '../utils/verifyPlainObject'\r\n\r\ntype AnyState = { [key: string]: any }\r\ntype StateOrDispatch<S extends AnyState = AnyState> = S | Dispatch\r\n\r\ntype AnyProps = { [key: string]: any }\r\n\r\nexport type MapToProps<P extends AnyProps = AnyProps> = {\r\n  // eslint-disable-next-line no-unused-vars\r\n  (stateOrDispatch: StateOrDispatch, ownProps?: P): FixTypeLater\r\n  dependsOnOwnProps?: boolean\r\n}\r\n\r\nexport function wrapMapToPropsConstant(\r\n  // * Note:\r\n  //  It seems that the dispatch argument\r\n  //  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\r\n  //  and a state object in some others (ex: whenMapStateToPropsIsMissing)\r\n  // eslint-disable-next-line no-unused-vars\r\n  getConstant: (dispatch: Dispatch) =>\r\n    | {\r\n        dispatch?: Dispatch\r\n        dependsOnOwnProps?: boolean\r\n      }\r\n    | ActionCreatorsMapObject\r\n    | ActionCreator<any>\r\n) {\r\n  return function initConstantSelector(dispatch: Dispatch) {\r\n    const constant = getConstant(dispatch)\r\n\r\n    function constantSelector() {\r\n      return constant\r\n    }\r\n    constantSelector.dependsOnOwnProps = false\r\n    return constantSelector\r\n  }\r\n}\r\n\r\n// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\r\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\r\n// whether mapToProps needs to be invoked when props have changed.\r\n//\r\n// A length of one signals that mapToProps does not depend on props from the parent component.\r\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\r\n// therefore not reporting its length accurately..\r\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\r\nexport function getDependsOnOwnProps(mapToProps: MapToProps) {\r\n  return mapToProps.dependsOnOwnProps\r\n    ? Boolean(mapToProps.dependsOnOwnProps)\r\n    : mapToProps.length !== 1\r\n}\r\n\r\n// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\r\n// this function wraps mapToProps in a proxy function which does several things:\r\n//\r\n//  * Detects whether the mapToProps function being called depends on props, which\r\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\r\n//\r\n//  * On first call, handles mapToProps if returns another function, and treats that\r\n//    new function as the true mapToProps for subsequent calls.\r\n//\r\n//  * On first call, verifies the first result is a plain object, in order to warn\r\n//    the developer that their mapToProps function is not returning a valid result.\r\n//\r\nexport function wrapMapToPropsFunc<P extends AnyProps = AnyProps>(\r\n  mapToProps: MapToProps,\r\n  methodName: string\r\n) {\r\n  return function initProxySelector(\r\n    dispatch: Dispatch,\r\n    { displayName }: { displayName: string }\r\n  ) {\r\n    const proxy = function mapToPropsProxy(\r\n      stateOrDispatch: StateOrDispatch,\r\n      ownProps?: P\r\n    ): MapToProps {\r\n      return proxy.dependsOnOwnProps\r\n        ? proxy.mapToProps(stateOrDispatch, ownProps)\r\n        : proxy.mapToProps(stateOrDispatch, undefined)\r\n    }\r\n\r\n    // allow detectFactoryAndVerify to get ownProps\r\n    proxy.dependsOnOwnProps = true\r\n\r\n    proxy.mapToProps = function detectFactoryAndVerify(\r\n      stateOrDispatch: StateOrDispatch,\r\n      ownProps?: P\r\n    ): MapToProps {\r\n      proxy.mapToProps = mapToProps\r\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)\r\n      let props = proxy(stateOrDispatch, ownProps)\r\n\r\n      if (typeof props === 'function') {\r\n        proxy.mapToProps = props\r\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)\r\n        props = proxy(stateOrDispatch, ownProps)\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production')\r\n        verifyPlainObject(props, displayName, methodName)\r\n\r\n      return props\r\n    }\r\n\r\n    return proxy\r\n  }\r\n}\r\n","import type { Action, Dispatch } from 'redux'\r\n\r\nexport function createInvalidArgFactory(arg: unknown, name: string) {\r\n  return (\r\n    dispatch: Dispatch<Action<string>>,\r\n    options: { readonly wrappedComponentName: string }\r\n  ) => {\r\n    throw new Error(\r\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${\r\n        options.wrappedComponentName\r\n      }.`\r\n    )\r\n  }\r\n}\r\n","import type { Action, Dispatch } from 'redux'\r\nimport bindActionCreators from '../utils/bindActionCreators'\r\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\r\nimport { createInvalidArgFactory } from './invalidArgFactory'\r\nimport type { MapDispatchToPropsParam } from './selectorFactory'\r\n\r\nexport function mapDispatchToPropsFactory<TDispatchProps, TOwnProps>(\r\n  mapDispatchToProps:\r\n    | MapDispatchToPropsParam<TDispatchProps, TOwnProps>\r\n    | undefined\r\n) {\r\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object'\r\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) =>\r\n        // @ts-ignore\r\n        bindActionCreators(mapDispatchToProps, dispatch)\r\n      )\r\n    : !mapDispatchToProps\r\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) => ({\r\n        dispatch,\r\n      }))\r\n    : typeof mapDispatchToProps === 'function'\r\n    ? // @ts-ignore\r\n      wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')\r\n    : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps')\r\n}\r\n","import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\r\nimport { createInvalidArgFactory } from './invalidArgFactory'\r\nimport type { MapStateToPropsParam } from './selectorFactory'\r\n\r\nexport function mapStateToPropsFactory<TStateProps, TOwnProps, State>(\r\n  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>\r\n) {\r\n  return !mapStateToProps\r\n    ? wrapMapToPropsConstant(() => ({}))\r\n    : typeof mapStateToProps === 'function'\r\n    ? // @ts-ignore\r\n      wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')\r\n    : createInvalidArgFactory(mapStateToProps, 'mapStateToProps')\r\n}\r\n","import type { Action, Dispatch } from 'redux'\r\nimport verifyPlainObject from '../utils/verifyPlainObject'\r\nimport { createInvalidArgFactory } from './invalidArgFactory'\r\nimport type { MergeProps } from './selectorFactory'\r\nimport type { EqualityFn } from '../types'\r\n\r\nexport function defaultMergeProps<\r\n  TStateProps,\r\n  TDispatchProps,\r\n  TOwnProps,\r\n  TMergedProps\r\n>(\r\n  stateProps: TStateProps,\r\n  dispatchProps: TDispatchProps,\r\n  ownProps: TOwnProps\r\n): TMergedProps {\r\n  // @ts-ignore\r\n  return { ...ownProps, ...stateProps, ...dispatchProps }\r\n}\r\n\r\nexport function wrapMergePropsFunc<\r\n  TStateProps,\r\n  TDispatchProps,\r\n  TOwnProps,\r\n  TMergedProps\r\n>(\r\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\r\n): (\r\n  dispatch: Dispatch<Action<string>>,\r\n  options: {\r\n    readonly displayName: string\r\n    readonly areMergedPropsEqual: EqualityFn<TMergedProps>\r\n  }\r\n) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> {\r\n  return function initMergePropsProxy(\r\n    dispatch,\r\n    { displayName, areMergedPropsEqual }\r\n  ) {\r\n    let hasRunOnce = false\r\n    let mergedProps: TMergedProps\r\n\r\n    return function mergePropsProxy(\r\n      stateProps: TStateProps,\r\n      dispatchProps: TDispatchProps,\r\n      ownProps: TOwnProps\r\n    ) {\r\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)\r\n\r\n      if (hasRunOnce) {\r\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\r\n          mergedProps = nextMergedProps\r\n      } else {\r\n        hasRunOnce = true\r\n        mergedProps = nextMergedProps\r\n\r\n        if (process.env.NODE_ENV !== 'production')\r\n          verifyPlainObject(mergedProps, displayName, 'mergeProps')\r\n      }\r\n\r\n      return mergedProps\r\n    }\r\n  }\r\n}\r\n\r\nexport function mergePropsFactory<\r\n  TStateProps,\r\n  TDispatchProps,\r\n  TOwnProps,\r\n  TMergedProps\r\n>(\r\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\r\n) {\r\n  return !mergeProps\r\n    ? () => defaultMergeProps\r\n    : typeof mergeProps === 'function'\r\n    ? wrapMergePropsFunc(mergeProps)\r\n    : createInvalidArgFactory(mergeProps, 'mergeProps')\r\n}\r\n","// Default to a dummy \"batch\" implementation that just runs the callback\r\nexport function defaultNoopBatch(callback: () => void) {\r\n  callback()\r\n}\r\n","import { defaultNoopBatch as batch } from './batch'\r\n\r\n// encapsulates the subscription logic for connecting a component to the redux store, as\r\n// well as nesting subscriptions of descendant components, so that we can ensure the\r\n// ancestor components re-render before descendants\r\n\r\ntype VoidFunc = () => void\r\n\r\ntype Listener = {\r\n  callback: VoidFunc\r\n  next: Listener | null\r\n  prev: Listener | null\r\n}\r\n\r\nfunction createListenerCollection() {\r\n  let first: Listener | null = null\r\n  let last: Listener | null = null\r\n\r\n  return {\r\n    clear() {\r\n      first = null\r\n      last = null\r\n    },\r\n\r\n    notify() {\r\n      batch(() => {\r\n        let listener = first\r\n        while (listener) {\r\n          listener.callback()\r\n          listener = listener.next\r\n        }\r\n      })\r\n    },\r\n\r\n    get() {\r\n      let listeners: Listener[] = []\r\n      let listener = first\r\n      while (listener) {\r\n        listeners.push(listener)\r\n        listener = listener.next\r\n      }\r\n      return listeners\r\n    },\r\n\r\n    subscribe(callback: () => void) {\r\n      let isSubscribed = true\r\n\r\n      let listener: Listener = (last = {\r\n        callback,\r\n        next: null,\r\n        prev: last,\r\n      })\r\n\r\n      if (listener.prev) {\r\n        listener.prev.next = listener\r\n      } else {\r\n        first = listener\r\n      }\r\n\r\n      return function unsubscribe() {\r\n        if (!isSubscribed || first === null) return\r\n        isSubscribed = false\r\n\r\n        if (listener.next) {\r\n          listener.next.prev = listener.prev\r\n        } else {\r\n          last = listener.prev\r\n        }\r\n        if (listener.prev) {\r\n          listener.prev.next = listener.next\r\n        } else {\r\n          first = listener.next\r\n        }\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\ntype ListenerCollection = ReturnType<typeof createListenerCollection>\r\n\r\nexport interface Subscription {\r\n  addNestedSub: (listener: VoidFunc) => VoidFunc\r\n  notifyNestedSubs: VoidFunc\r\n  handleChangeWrapper: VoidFunc\r\n  isSubscribed: () => boolean\r\n  onStateChange?: VoidFunc | null\r\n  trySubscribe: VoidFunc\r\n  tryUnsubscribe: VoidFunc\r\n  getListeners: () => ListenerCollection\r\n}\r\n\r\nconst nullListeners = {\r\n  notify() {},\r\n  get: () => [],\r\n} as unknown as ListenerCollection\r\n\r\nexport function createSubscription(store: any, parentSub?: Subscription) {\r\n  let unsubscribe: VoidFunc | undefined\r\n  let listeners: ListenerCollection = nullListeners\r\n\r\n  // Reasons to keep the subscription active\r\n  let subscriptionsAmount = 0\r\n\r\n  // Is this specific subscription subscribed (or only nested ones?)\r\n  let selfSubscribed = false\r\n\r\n  function addNestedSub(listener: () => void) {\r\n    trySubscribe()\r\n\r\n    const cleanupListener = listeners.subscribe(listener)\r\n\r\n    // cleanup nested sub\r\n    let removed = false\r\n    return () => {\r\n      if (!removed) {\r\n        removed = true\r\n        cleanupListener()\r\n        tryUnsubscribe()\r\n      }\r\n    }\r\n  }\r\n\r\n  function notifyNestedSubs() {\r\n    listeners.notify()\r\n  }\r\n\r\n  function handleChangeWrapper() {\r\n    if (subscription.onStateChange) {\r\n      subscription.onStateChange()\r\n    }\r\n  }\r\n\r\n  function isSubscribed() {\r\n    return selfSubscribed\r\n  }\r\n\r\n  function trySubscribe() {\r\n    subscriptionsAmount++\r\n    if (!unsubscribe) {\r\n      unsubscribe = parentSub\r\n        ? parentSub.addNestedSub(handleChangeWrapper)\r\n        : store.subscribe(handleChangeWrapper)\r\n\r\n      listeners = createListenerCollection()\r\n    }\r\n  }\r\n\r\n  function tryUnsubscribe() {\r\n    subscriptionsAmount--\r\n    if (unsubscribe && subscriptionsAmount === 0) {\r\n      unsubscribe()\r\n      unsubscribe = undefined\r\n      listeners.clear()\r\n      listeners = nullListeners\r\n    }\r\n  }\r\n\r\n  function trySubscribeSelf() {\r\n    if (!selfSubscribed) {\r\n      selfSubscribed = true\r\n      trySubscribe()\r\n    }\r\n  }\r\n\r\n  function tryUnsubscribeSelf() {\r\n    if (selfSubscribed) {\r\n      selfSubscribed = false\r\n      tryUnsubscribe()\r\n    }\r\n  }\r\n\r\n  const subscription: Subscription = {\r\n    addNestedSub,\r\n    notifyNestedSubs,\r\n    handleChangeWrapper,\r\n    isSubscribed,\r\n    trySubscribe: trySubscribeSelf,\r\n    tryUnsubscribe: tryUnsubscribeSelf,\r\n    getListeners: () => listeners,\r\n  }\r\n\r\n  return subscription\r\n}\r\n","import { React } from '../utils/react'\r\n\r\n// React currently throws a warning when using useLayoutEffect on the server.\r\n// To get around it, we can conditionally useEffect on the server (no-op) and\r\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\r\n// subscription callback always has the selector from the latest render commit\r\n// available, otherwise a store update may happen between render and the effect,\r\n// which may cause missed updates; we also must ensure the store subscription\r\n// is created synchronously, otherwise a store update may occur before the\r\n// subscription is created and an inconsistent state may be observed\r\n\r\n// Matches logic in React's `shared/ExecutionEnvironment` file\r\nexport const canUseDOM = !!(\r\n  typeof window !== 'undefined' &&\r\n  typeof window.document !== 'undefined' &&\r\n  typeof window.document.createElement !== 'undefined'\r\n)\r\n\r\nexport const useIsomorphicLayoutEffect = canUseDOM\r\n  ? React.useLayoutEffect\r\n  : React.useEffect\r\n","function is(x: unknown, y: unknown) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\r\n  } else {\r\n    return x !== x && y !== y\r\n  }\r\n}\r\n\r\nexport default function shallowEqual(objA: any, objB: any) {\r\n  if (is(objA, objB)) return true\r\n\r\n  if (\r\n    typeof objA !== 'object' ||\r\n    objA === null ||\r\n    typeof objB !== 'object' ||\r\n    objB === null\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  const keysA = Object.keys(objA)\r\n  const keysB = Object.keys(objB)\r\n\r\n  if (keysA.length !== keysB.length) return false\r\n\r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (\r\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\r\n      !is(objA[keysA[i]], objB[keysA[i]])\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","// Copied directly from:\r\n// https://github.com/mridgway/hoist-non-react-statics/blob/main/src/index.js\r\n// https://unpkg.com/browse/@types/hoist-non-react-statics@3.3.1/index.d.ts\r\n\r\n/**\r\n * Copyright 2015, Yahoo! Inc.\r\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\r\nimport type * as React from 'react'\r\nimport { ForwardRef, Memo, isMemo } from '../utils/react-is'\r\n\r\nconst REACT_STATICS = {\r\n  childContextTypes: true,\r\n  contextType: true,\r\n  contextTypes: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  getDefaultProps: true,\r\n  getDerivedStateFromError: true,\r\n  getDerivedStateFromProps: true,\r\n  mixins: true,\r\n  propTypes: true,\r\n  type: true,\r\n} as const\r\n\r\nconst KNOWN_STATICS = {\r\n  name: true,\r\n  length: true,\r\n  prototype: true,\r\n  caller: true,\r\n  callee: true,\r\n  arguments: true,\r\n  arity: true,\r\n} as const\r\n\r\nconst FORWARD_REF_STATICS = {\r\n  $$typeof: true,\r\n  render: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  propTypes: true,\r\n} as const\r\n\r\nconst MEMO_STATICS = {\r\n  $$typeof: true,\r\n  compare: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  propTypes: true,\r\n  type: true,\r\n} as const\r\n\r\nconst TYPE_STATICS = {\r\n  [ForwardRef]: FORWARD_REF_STATICS,\r\n  [Memo]: MEMO_STATICS,\r\n} as const\r\n\r\nfunction getStatics(component: any) {\r\n  // React v16.11 and below\r\n  if (isMemo(component)) {\r\n    return MEMO_STATICS\r\n  }\r\n\r\n  // React v16.12 and above\r\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS\r\n}\r\n\r\nexport type NonReactStatics<\r\n  S extends React.ComponentType<any>,\r\n  C extends {\r\n    [key: string]: true\r\n  } = {}\r\n> = {\r\n  [key in Exclude<\r\n    keyof S,\r\n    S extends React.MemoExoticComponent<any>\r\n      ? keyof typeof MEMO_STATICS | keyof C\r\n      : S extends React.ForwardRefExoticComponent<any>\r\n      ? keyof typeof FORWARD_REF_STATICS | keyof C\r\n      : keyof typeof REACT_STATICS | keyof typeof KNOWN_STATICS | keyof C\r\n  >]: S[key]\r\n}\r\n\r\nconst defineProperty = Object.defineProperty\r\nconst getOwnPropertyNames = Object.getOwnPropertyNames\r\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols\r\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\r\nconst getPrototypeOf = Object.getPrototypeOf\r\nconst objectPrototype = Object.prototype\r\n\r\nexport default function hoistNonReactStatics<\r\n  T extends React.ComponentType<any>,\r\n  S extends React.ComponentType<any>,\r\n  C extends {\r\n    [key: string]: true\r\n  } = {}\r\n>(targetComponent: T, sourceComponent: S): T & NonReactStatics<S, C> {\r\n  if (typeof sourceComponent !== 'string') {\r\n    // don't hoist over string (html) components\r\n\r\n    if (objectPrototype) {\r\n      const inheritedComponent = getPrototypeOf(sourceComponent)\r\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\r\n        hoistNonReactStatics(targetComponent, inheritedComponent)\r\n      }\r\n    }\r\n\r\n    let keys: (string | symbol)[] = getOwnPropertyNames(sourceComponent)\r\n\r\n    if (getOwnPropertySymbols) {\r\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent))\r\n    }\r\n\r\n    const targetStatics = getStatics(targetComponent)\r\n    const sourceStatics = getStatics(sourceComponent)\r\n\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const key = keys[i]\r\n      if (\r\n        !KNOWN_STATICS[key as keyof typeof KNOWN_STATICS] &&\r\n        !(sourceStatics && sourceStatics[key as keyof typeof sourceStatics]) &&\r\n        !(targetStatics && targetStatics[key as keyof typeof targetStatics])\r\n      ) {\r\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key)\r\n        try {\r\n          // Avoid failures from read-only properties\r\n          defineProperty(targetComponent, key, descriptor!)\r\n        } catch (e) {\r\n          // ignore\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return targetComponent as any\r\n}\r\n","/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\r\nimport type { ComponentType } from 'react'\r\nimport { React } from '../utils/react'\r\nimport { isValidElementType, isContextConsumer } from '../utils/react-is'\r\n\r\nimport type { Store } from 'redux'\r\n\r\nimport type {\r\n  ConnectedComponent,\r\n  InferableComponentEnhancer,\r\n  InferableComponentEnhancerWithProps,\r\n  ResolveThunks,\r\n  DispatchProp,\r\n  ConnectPropsMaybeWithoutContext,\r\n} from '../types'\r\n\r\nimport type {\r\n  MapStateToPropsParam,\r\n  MapDispatchToPropsParam,\r\n  MergeProps,\r\n  MapDispatchToPropsNonObject,\r\n  SelectorFactoryOptions,\r\n} from '../connect/selectorFactory'\r\nimport defaultSelectorFactory from '../connect/selectorFactory'\r\nimport { mapDispatchToPropsFactory } from '../connect/mapDispatchToProps'\r\nimport { mapStateToPropsFactory } from '../connect/mapStateToProps'\r\nimport { mergePropsFactory } from '../connect/mergeProps'\r\n\r\nimport type { Subscription } from '../utils/Subscription'\r\nimport { createSubscription } from '../utils/Subscription'\r\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\r\nimport shallowEqual from '../utils/shallowEqual'\r\nimport hoistStatics from '../utils/hoistStatics'\r\nimport warning from '../utils/warning'\r\n\r\nimport type {\r\n  ReactReduxContextValue,\r\n  ReactReduxContextInstance,\r\n} from './Context'\r\nimport { ReactReduxContext } from './Context'\r\n\r\nimport type { uSES } from '../utils/useSyncExternalStore'\r\nimport { notInitialized } from '../utils/useSyncExternalStore'\r\n\r\nlet useSyncExternalStore = notInitialized as uSES\r\nexport const initializeConnect = (fn: uSES) => {\r\n  useSyncExternalStore = fn\r\n}\r\n\r\n// Define some constant arrays just to avoid re-creating these\r\nconst EMPTY_ARRAY: [unknown, number] = [null, 0]\r\nconst NO_SUBSCRIPTION_ARRAY = [null, null]\r\n\r\n// Attempts to stringify whatever not-really-a-component value we were given\r\n// for logging in an error message\r\nconst stringifyComponent = (Comp: unknown) => {\r\n  try {\r\n    return JSON.stringify(Comp)\r\n  } catch (err) {\r\n    return String(Comp)\r\n  }\r\n}\r\n\r\ntype EffectFunc = (...args: any[]) => void | ReturnType<React.EffectCallback>\r\n\r\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\r\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\r\n// - we extract this to a separate function to avoid closing over values\r\n//   and causing memory leaks\r\nfunction useIsomorphicLayoutEffectWithArgs(\r\n  effectFunc: EffectFunc,\r\n  effectArgs: any[],\r\n  dependencies?: React.DependencyList\r\n) {\r\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies)\r\n}\r\n\r\n// Effect callback, extracted: assign the latest props values to refs for later usage\r\nfunction captureWrapperProps(\r\n  lastWrapperProps: React.MutableRefObject<unknown>,\r\n  lastChildProps: React.MutableRefObject<unknown>,\r\n  renderIsScheduled: React.MutableRefObject<boolean>,\r\n  wrapperProps: unknown,\r\n  // actualChildProps: unknown,\r\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\r\n  notifyNestedSubs: () => void\r\n) {\r\n  // We want to capture the wrapper props and child props we used for later comparisons\r\n  lastWrapperProps.current = wrapperProps\r\n  renderIsScheduled.current = false\r\n\r\n  // If the render was from a store update, clear out that reference and cascade the subscriber update\r\n  if (childPropsFromStoreUpdate.current) {\r\n    childPropsFromStoreUpdate.current = null\r\n    notifyNestedSubs()\r\n  }\r\n}\r\n\r\n// Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\r\n// check for updates after dispatched actions, and trigger re-renders.\r\nfunction subscribeUpdates(\r\n  shouldHandleStateChanges: boolean,\r\n  store: Store,\r\n  subscription: Subscription,\r\n  childPropsSelector: (state: unknown, props: unknown) => unknown,\r\n  lastWrapperProps: React.MutableRefObject<unknown>,\r\n  lastChildProps: React.MutableRefObject<unknown>,\r\n  renderIsScheduled: React.MutableRefObject<boolean>,\r\n  isMounted: React.MutableRefObject<boolean>,\r\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\r\n  notifyNestedSubs: () => void,\r\n  // forceComponentUpdateDispatch: React.Dispatch<any>,\r\n  additionalSubscribeListener: () => void\r\n) {\r\n  // If we're not subscribed to the store, nothing to do here\r\n  if (!shouldHandleStateChanges) return () => {}\r\n\r\n  // Capture values for checking if and when this component unmounts\r\n  let didUnsubscribe = false\r\n  let lastThrownError: Error | null = null\r\n\r\n  // We'll run this callback every time a store subscription update propagates to this component\r\n  const checkForUpdates = () => {\r\n    if (didUnsubscribe || !isMounted.current) {\r\n      // Don't run stale listeners.\r\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\r\n      return\r\n    }\r\n\r\n    // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\r\n    const latestStoreState = store.getState()\r\n\r\n    let newChildProps, error\r\n    try {\r\n      // Actually run the selector with the most recent store state and wrapper props\r\n      // to determine what the child props should be\r\n      newChildProps = childPropsSelector(\r\n        latestStoreState,\r\n        lastWrapperProps.current\r\n      )\r\n    } catch (e) {\r\n      error = e\r\n      lastThrownError = e as Error | null\r\n    }\r\n\r\n    if (!error) {\r\n      lastThrownError = null\r\n    }\r\n\r\n    // If the child props haven't changed, nothing to do here - cascade the subscription update\r\n    if (newChildProps === lastChildProps.current) {\r\n      if (!renderIsScheduled.current) {\r\n        notifyNestedSubs()\r\n      }\r\n    } else {\r\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\r\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\r\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\r\n      // forcing another re-render, which we don't want.\r\n      lastChildProps.current = newChildProps\r\n      childPropsFromStoreUpdate.current = newChildProps\r\n      renderIsScheduled.current = true\r\n\r\n      // TODO This is hacky and not how `uSES` is meant to be used\r\n      // Trigger the React `useSyncExternalStore` subscriber\r\n      additionalSubscribeListener()\r\n    }\r\n  }\r\n\r\n  // Actually subscribe to the nearest connected ancestor (or store)\r\n  subscription.onStateChange = checkForUpdates\r\n  subscription.trySubscribe()\r\n\r\n  // Pull data from the store after first render in case the store has\r\n  // changed since we began.\r\n  checkForUpdates()\r\n\r\n  const unsubscribeWrapper = () => {\r\n    didUnsubscribe = true\r\n    subscription.tryUnsubscribe()\r\n    subscription.onStateChange = null\r\n\r\n    if (lastThrownError) {\r\n      // It's possible that we caught an error due to a bad mapState function, but the\r\n      // parent re-rendered without this component and we're about to unmount.\r\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\r\n      // if we ever do those wrong, this throw will surface the error in our tests.\r\n      // In that case, throw the error from here so it doesn't get lost.\r\n      throw lastThrownError\r\n    }\r\n  }\r\n\r\n  return unsubscribeWrapper\r\n}\r\n\r\n// Reducer initial state creation for our update reducer\r\nconst initStateUpdates = () => EMPTY_ARRAY\r\n\r\nexport interface ConnectProps {\r\n  /** A custom Context instance that the component can use to access the store from an alternate Provider using that same Context instance */\r\n  context?: ReactReduxContextInstance\r\n  /** A Redux store instance to be used for subscriptions instead of the store from a Provider */\r\n  store?: Store\r\n}\r\n\r\ninterface InternalConnectProps extends ConnectProps {\r\n  reactReduxForwardedRef?: React.ForwardedRef<unknown>\r\n}\r\n\r\nfunction strictEqual(a: unknown, b: unknown) {\r\n  return a === b\r\n}\r\n\r\n/**\r\n * Infers the type of props that a connector will inject into a component.\r\n */\r\nexport type ConnectedProps<TConnector> =\r\n  TConnector extends InferableComponentEnhancerWithProps<\r\n    infer TInjectedProps,\r\n    any\r\n  >\r\n    ? unknown extends TInjectedProps\r\n      ? TConnector extends InferableComponentEnhancer<infer TInjectedProps>\r\n        ? TInjectedProps\r\n        : never\r\n      : TInjectedProps\r\n    : never\r\n\r\nexport interface ConnectOptions<\r\n  State = unknown,\r\n  TStateProps = {},\r\n  TOwnProps = {},\r\n  TMergedProps = {}\r\n> {\r\n  forwardRef?: boolean\r\n  context?: typeof ReactReduxContext\r\n  areStatesEqual?: (\r\n    nextState: State,\r\n    prevState: State,\r\n    nextOwnProps: TOwnProps,\r\n    prevOwnProps: TOwnProps\r\n  ) => boolean\r\n\r\n  areOwnPropsEqual?: (\r\n    nextOwnProps: TOwnProps,\r\n    prevOwnProps: TOwnProps\r\n  ) => boolean\r\n\r\n  areStatePropsEqual?: (\r\n    nextStateProps: TStateProps,\r\n    prevStateProps: TStateProps\r\n  ) => boolean\r\n  areMergedPropsEqual?: (\r\n    nextMergedProps: TMergedProps,\r\n    prevMergedProps: TMergedProps\r\n  ) => boolean\r\n}\r\n\r\n/**\r\n * Connects a React component to a Redux store.\r\n *\r\n * - Without arguments, just wraps the component, without changing the behavior / props\r\n *\r\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\r\n * is to override ownProps (as stated in the docs), so what remains is everything that's\r\n * not a state or dispatch prop\r\n *\r\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\r\n * should be valid component props, because it depends on mergeProps implementation.\r\n * As such, it is the user's responsibility to extend ownProps interface from state or\r\n * dispatch props or both when applicable\r\n *\r\n * @param mapStateToProps\r\n * @param mapDispatchToProps\r\n * @param mergeProps\r\n * @param options\r\n */\r\nexport interface Connect<DefaultState = unknown> {\r\n  // tslint:disable:no-unnecessary-generics\r\n  (): InferableComponentEnhancer<DispatchProp>\r\n\r\n  /** mapState only */\r\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>\r\n  ): InferableComponentEnhancerWithProps<TStateProps & DispatchProp, TOwnProps>\r\n\r\n  /** mapDispatch only (as a function) */\r\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\r\n\r\n  /** mapDispatch only (as an object) */\r\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    ResolveThunks<TDispatchProps>,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mapState and mapDispatch (as a function)*/\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    TStateProps & TDispatchProps,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mapState and mapDispatch (nullish) */\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: null | undefined\r\n  ): InferableComponentEnhancerWithProps<TStateProps, TOwnProps>\r\n\r\n  /** mapState and mapDispatch (as an object) */\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    TStateProps & ResolveThunks<TDispatchProps>,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mergeProps only */\r\n  <no_state = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: null | undefined,\r\n    mergeProps: MergeProps<undefined, DispatchProp, TOwnProps, TMergedProps>\r\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\r\n\r\n  /** mapState and mergeProps */\r\n  <\r\n    TStateProps = {},\r\n    no_dispatch = {},\r\n    TOwnProps = {},\r\n    TMergedProps = {},\r\n    State = DefaultState\r\n  >(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: null | undefined,\r\n    mergeProps: MergeProps<TStateProps, DispatchProp, TOwnProps, TMergedProps>\r\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\r\n\r\n  /** mapDispatch (as a object) and mergeProps */\r\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\r\n    mergeProps: MergeProps<undefined, TDispatchProps, TOwnProps, TMergedProps>\r\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\r\n\r\n  /** mapState and options */\r\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: null | undefined,\r\n    mergeProps: null | undefined,\r\n    options: ConnectOptions<State, TStateProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<DispatchProp & TStateProps, TOwnProps>\r\n\r\n  /** mapDispatch (as a function) and options */\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\r\n    mergeProps: null | undefined,\r\n    options: ConnectOptions<{}, TStateProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\r\n\r\n  /** mapDispatch (as an object) and options*/\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\r\n    mapStateToProps: null | undefined,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\r\n    mergeProps: null | undefined,\r\n    options: ConnectOptions<{}, TStateProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    ResolveThunks<TDispatchProps>,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mapState,  mapDispatch (as a function), and options */\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\r\n    mergeProps: null | undefined,\r\n    options: ConnectOptions<State, TStateProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    TStateProps & TDispatchProps,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mapState,  mapDispatch (as an object), and options */\r\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\r\n    mergeProps: null | undefined,\r\n    options: ConnectOptions<State, TStateProps, TOwnProps>\r\n  ): InferableComponentEnhancerWithProps<\r\n    TStateProps & ResolveThunks<TDispatchProps>,\r\n    TOwnProps\r\n  >\r\n\r\n  /** mapState, mapDispatch, mergeProps, and options */\r\n  <\r\n    TStateProps = {},\r\n    TDispatchProps = {},\r\n    TOwnProps = {},\r\n    TMergedProps = {},\r\n    State = DefaultState\r\n  >(\r\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\r\n    mergeProps: MergeProps<\r\n      TStateProps,\r\n      TDispatchProps,\r\n      TOwnProps,\r\n      TMergedProps\r\n    >,\r\n    options?: ConnectOptions<State, TStateProps, TOwnProps, TMergedProps>\r\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\r\n  // tslint:enable:no-unnecessary-generics\r\n}\r\n\r\nlet hasWarnedAboutDeprecatedPureOption = false\r\n\r\n/**\r\n * Connects a React component to a Redux store.\r\n *\r\n * - Without arguments, just wraps the component, without changing the behavior / props\r\n *\r\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\r\n * is to override ownProps (as stated in the docs), so what remains is everything that's\r\n * not a state or dispatch prop\r\n *\r\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\r\n * should be valid component props, because it depends on mergeProps implementation.\r\n * As such, it is the user's responsibility to extend ownProps interface from state or\r\n * dispatch props or both when applicable\r\n *\r\n * @param mapStateToProps A function that extracts values from state\r\n * @param mapDispatchToProps Setup for dispatching actions\r\n * @param mergeProps Optional callback to merge state and dispatch props together\r\n * @param options Options for configuring the connection\r\n *\r\n */\r\nfunction connect<\r\n  TStateProps = {},\r\n  TDispatchProps = {},\r\n  TOwnProps = {},\r\n  TMergedProps = {},\r\n  State = unknown\r\n>(\r\n  mapStateToProps?: MapStateToPropsParam<TStateProps, TOwnProps, State>,\r\n  mapDispatchToProps?: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\r\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\r\n  {\r\n    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\r\n    // @ts-ignore\r\n    pure,\r\n    areStatesEqual = strictEqual,\r\n    areOwnPropsEqual = shallowEqual,\r\n    areStatePropsEqual = shallowEqual,\r\n    areMergedPropsEqual = shallowEqual,\r\n\r\n    // use React's forwardRef to expose a ref of the wrapped component\r\n    forwardRef = false,\r\n\r\n    // the context consumer to use\r\n    context = ReactReduxContext,\r\n  }: ConnectOptions<unknown, unknown, unknown, unknown> = {}\r\n): unknown {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\r\n      hasWarnedAboutDeprecatedPureOption = true\r\n      warning(\r\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component'\r\n      )\r\n    }\r\n  }\r\n\r\n  const Context = context\r\n\r\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps)\r\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps)\r\n  const initMergeProps = mergePropsFactory(mergeProps)\r\n\r\n  const shouldHandleStateChanges = Boolean(mapStateToProps)\r\n\r\n  const wrapWithConnect = <TProps,>(\r\n    WrappedComponent: ComponentType<TProps>\r\n  ) => {\r\n    type WrappedComponentProps = TProps &\r\n      ConnectPropsMaybeWithoutContext<TProps>\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      const isValid = /*#__PURE__*/ isValidElementType(WrappedComponent)\r\n      if (!isValid)\r\n        throw new Error(\r\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\r\n            WrappedComponent\r\n          )}`\r\n        )\r\n    }\r\n\r\n    const wrappedComponentName =\r\n      WrappedComponent.displayName || WrappedComponent.name || 'Component'\r\n\r\n    const displayName = `Connect(${wrappedComponentName})`\r\n\r\n    const selectorFactoryOptions: SelectorFactoryOptions<\r\n      any,\r\n      any,\r\n      any,\r\n      any,\r\n      State\r\n    > = {\r\n      shouldHandleStateChanges,\r\n      displayName,\r\n      wrappedComponentName,\r\n      WrappedComponent,\r\n      // @ts-ignore\r\n      initMapStateToProps,\r\n      // @ts-ignore\r\n      initMapDispatchToProps,\r\n      initMergeProps,\r\n      areStatesEqual,\r\n      areStatePropsEqual,\r\n      areOwnPropsEqual,\r\n      areMergedPropsEqual,\r\n    }\r\n\r\n    function ConnectFunction<TOwnProps>(\r\n      props: InternalConnectProps & TOwnProps\r\n    ) {\r\n      const [propsContext, reactReduxForwardedRef, wrapperProps] =\r\n        React.useMemo(() => {\r\n          // Distinguish between actual \"data\" props that were passed to the wrapper component,\r\n          // and values needed to control behavior (forwarded refs, alternate context instances).\r\n          // To maintain the wrapperProps object reference, memoize this destructuring.\r\n          const { reactReduxForwardedRef, ...wrapperProps } = props\r\n          return [props.context, reactReduxForwardedRef, wrapperProps]\r\n        }, [props])\r\n\r\n      const ContextToUse: ReactReduxContextInstance = React.useMemo(() => {\r\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\r\n        // Memoize the check that determines which context instance we should use.\r\n        let ResultContext = Context\r\n        if (propsContext?.Consumer) {\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            const isValid = /*#__PURE__*/ isContextConsumer(\r\n              // @ts-ignore\r\n              <propsContext.Consumer />\r\n            )\r\n            if (!isValid) {\r\n              throw new Error(\r\n                'You must pass a valid React context consumer as `props.context`'\r\n              )\r\n            }\r\n            ResultContext = propsContext\r\n          }\r\n        }\r\n        return ResultContext\r\n      }, [propsContext, Context])\r\n\r\n      // Retrieve the store and ancestor subscription via context, if available\r\n      const contextValue = React.useContext(ContextToUse)\r\n\r\n      // The store _must_ exist as either a prop or in context.\r\n      // We'll check to see if it _looks_ like a Redux store first.\r\n      // This allows us to pass through a `store` prop that is just a plain value.\r\n      const didStoreComeFromProps =\r\n        Boolean(props.store) &&\r\n        Boolean(props.store!.getState) &&\r\n        Boolean(props.store!.dispatch)\r\n      const didStoreComeFromContext =\r\n        Boolean(contextValue) && Boolean(contextValue!.store)\r\n\r\n      if (\r\n        process.env.NODE_ENV !== 'production' &&\r\n        !didStoreComeFromProps &&\r\n        !didStoreComeFromContext\r\n      ) {\r\n        throw new Error(\r\n          `Could not find \"store\" in the context of ` +\r\n            `\"${displayName}\". Either wrap the root component in a <Provider>, ` +\r\n            `or pass a custom React context provider to <Provider> and the corresponding ` +\r\n            `React context consumer to ${displayName} in connect options.`\r\n        )\r\n      }\r\n\r\n      // Based on the previous check, one of these must be true\r\n      const store: Store = didStoreComeFromProps\r\n        ? props.store!\r\n        : contextValue!.store\r\n\r\n      const getServerState = didStoreComeFromContext\r\n        ? contextValue!.getServerState\r\n        : store.getState\r\n\r\n      const childPropsSelector = React.useMemo(() => {\r\n        // The child props selector needs the store reference as an input.\r\n        // Re-create this selector whenever the store changes.\r\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions)\r\n      }, [store])\r\n\r\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\r\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\r\n\r\n        // This Subscription's source should match where store came from: props vs. context. A component\r\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\r\n        const subscription = createSubscription(\r\n          store,\r\n          didStoreComeFromProps ? undefined : contextValue!.subscription\r\n        )\r\n\r\n        // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\r\n        // the middle of the notification loop, where `subscription` will then be null. This can\r\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\r\n        // that have been unsubscribed in the  middle of the notification loop.\r\n        const notifyNestedSubs =\r\n          subscription.notifyNestedSubs.bind(subscription)\r\n\r\n        return [subscription, notifyNestedSubs]\r\n      }, [store, didStoreComeFromProps, contextValue])\r\n\r\n      // Determine what {store, subscription} value should be put into nested context, if necessary,\r\n      // and memoize that value to avoid unnecessary context updates.\r\n      const overriddenContextValue = React.useMemo(() => {\r\n        if (didStoreComeFromProps) {\r\n          // This component is directly subscribed to a store from props.\r\n          // We don't want descendants reading from this store - pass down whatever\r\n          // the existing context value is from the nearest connected ancestor.\r\n          return contextValue!\r\n        }\r\n\r\n        // Otherwise, put this component's subscription instance into context, so that\r\n        // connected descendants won't update until after this component is done\r\n        return {\r\n          ...contextValue,\r\n          subscription,\r\n        } as ReactReduxContextValue\r\n      }, [didStoreComeFromProps, contextValue, subscription])\r\n\r\n      // Set up refs to coordinate values between the subscription effect and the render logic\r\n      const lastChildProps = React.useRef<unknown>()\r\n      const lastWrapperProps = React.useRef(wrapperProps)\r\n      const childPropsFromStoreUpdate = React.useRef<unknown>()\r\n      const renderIsScheduled = React.useRef(false)\r\n      const isProcessingDispatch = React.useRef(false)\r\n      const isMounted = React.useRef(false)\r\n\r\n      const latestSubscriptionCallbackError = React.useRef<Error>()\r\n\r\n      useIsomorphicLayoutEffect(() => {\r\n        isMounted.current = true\r\n        return () => {\r\n          isMounted.current = false\r\n        }\r\n      }, [])\r\n\r\n      const actualChildPropsSelector = React.useMemo(() => {\r\n        const selector = () => {\r\n          // Tricky logic here:\r\n          // - This render may have been triggered by a Redux store update that produced new child props\r\n          // - However, we may have gotten new wrapper props after that\r\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\r\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\r\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\r\n          if (\r\n            childPropsFromStoreUpdate.current &&\r\n            wrapperProps === lastWrapperProps.current\r\n          ) {\r\n            return childPropsFromStoreUpdate.current\r\n          }\r\n\r\n          // TODO We're reading the store directly in render() here. Bad idea?\r\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\r\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\r\n          // to determine what the child props should be.\r\n          return childPropsSelector(store.getState(), wrapperProps)\r\n        }\r\n        return selector\r\n      }, [store, wrapperProps])\r\n\r\n      // We need this to execute synchronously every time we re-render. However, React warns\r\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\r\n      // just useEffect instead to avoid the warning, since neither will run anyway.\r\n\r\n      const subscribeForReact = React.useMemo(() => {\r\n        const subscribe = (reactListener: () => void) => {\r\n          if (!subscription) {\r\n            return () => {}\r\n          }\r\n\r\n          return subscribeUpdates(\r\n            shouldHandleStateChanges,\r\n            store,\r\n            subscription,\r\n            // @ts-ignore\r\n            childPropsSelector,\r\n            lastWrapperProps,\r\n            lastChildProps,\r\n            renderIsScheduled,\r\n            isMounted,\r\n            childPropsFromStoreUpdate,\r\n            notifyNestedSubs,\r\n            reactListener\r\n          )\r\n        }\r\n\r\n        return subscribe\r\n      }, [subscription])\r\n\r\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\r\n        lastWrapperProps,\r\n        lastChildProps,\r\n        renderIsScheduled,\r\n        wrapperProps,\r\n        childPropsFromStoreUpdate,\r\n        notifyNestedSubs,\r\n      ])\r\n\r\n      let actualChildProps: Record<string, unknown>\r\n\r\n      try {\r\n        actualChildProps = useSyncExternalStore(\r\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\r\n          subscribeForReact,\r\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\r\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\r\n          actualChildPropsSelector,\r\n          getServerState\r\n            ? () => childPropsSelector(getServerState(), wrapperProps)\r\n            : actualChildPropsSelector\r\n        )\r\n      } catch (err) {\r\n        if (latestSubscriptionCallbackError.current) {\r\n          ;(\r\n            err as Error\r\n          ).message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`\r\n        }\r\n\r\n        throw err\r\n      }\r\n\r\n      useIsomorphicLayoutEffect(() => {\r\n        latestSubscriptionCallbackError.current = undefined\r\n        childPropsFromStoreUpdate.current = undefined\r\n        lastChildProps.current = actualChildProps\r\n      })\r\n\r\n      // Now that all that's done, we can finally try to actually render the child component.\r\n      // We memoize the elements for the rendered child component as an optimization.\r\n      const renderedWrappedComponent = React.useMemo(() => {\r\n        return (\r\n          // @ts-ignore\r\n          <WrappedComponent\r\n            {...actualChildProps}\r\n            ref={reactReduxForwardedRef}\r\n          />\r\n        )\r\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps])\r\n\r\n      // If React sees the exact same element reference as last time, it bails out of re-rendering\r\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\r\n      const renderedChild = React.useMemo(() => {\r\n        if (shouldHandleStateChanges) {\r\n          // If this component is subscribed to store updates, we need to pass its own\r\n          // subscription instance down to our descendants. That means rendering the same\r\n          // Context instance, and putting a different value into the context.\r\n          return (\r\n            <ContextToUse.Provider value={overriddenContextValue}>\r\n              {renderedWrappedComponent}\r\n            </ContextToUse.Provider>\r\n          )\r\n        }\r\n\r\n        return renderedWrappedComponent\r\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\r\n\r\n      return renderedChild\r\n    }\r\n\r\n    const _Connect = React.memo(ConnectFunction)\r\n\r\n    type ConnectedWrapperComponent = typeof _Connect & {\r\n      WrappedComponent: typeof WrappedComponent\r\n    }\r\n\r\n    // Add a hacky cast to get the right output type\r\n    const Connect = _Connect as unknown as ConnectedComponent<\r\n      typeof WrappedComponent,\r\n      WrappedComponentProps\r\n    >\r\n    Connect.WrappedComponent = WrappedComponent\r\n    Connect.displayName = ConnectFunction.displayName = displayName\r\n\r\n    if (forwardRef) {\r\n      const _forwarded = React.forwardRef(function forwardConnectRef(\r\n        props,\r\n        ref\r\n      ) {\r\n        // @ts-ignore\r\n        return <Connect {...props} reactReduxForwardedRef={ref} />\r\n      })\r\n\r\n      const forwarded = _forwarded as ConnectedWrapperComponent\r\n      forwarded.displayName = displayName\r\n      forwarded.WrappedComponent = WrappedComponent\r\n      return /*#__PURE__*/ hoistStatics(forwarded, WrappedComponent)\r\n    }\r\n\r\n    return /*#__PURE__*/ hoistStatics(Connect, WrappedComponent)\r\n  }\r\n\r\n  return wrapWithConnect\r\n}\r\n\r\nexport default connect as Connect\r\n","import type { Context, ReactNode } from 'react'\r\nimport { React } from '../utils/react'\r\nimport type { Action, Store, UnknownAction } from 'redux'\r\nimport type { DevModeCheckFrequency } from '../hooks/useSelector'\r\nimport { createSubscription } from '../utils/Subscription'\r\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\r\nimport type { ReactReduxContextValue } from './Context'\r\nimport { ReactReduxContext } from './Context'\r\n\r\nexport interface ProviderProps<\r\n  A extends Action<string> = UnknownAction,\r\n  S = unknown\r\n> {\r\n  /**\r\n   * The single Redux store in your application.\r\n   */\r\n  store: Store<S, A>\r\n\r\n  /**\r\n   * An optional server state snapshot. Will be used during initial hydration render if available, to ensure that the UI output is consistent with the HTML generated on the server.\r\n   */\r\n  serverState?: S\r\n\r\n  /**\r\n   * Optional context to be used internally in react-redux. Use React.createContext() to create a context to be used.\r\n   * If this is used, you'll need to customize `connect` by supplying the same context provided to the Provider.\r\n   * Set the initial value to null, and the hooks will error\r\n   * if this is not overwritten by Provider.\r\n   */\r\n  context?: Context<ReactReduxContextValue<S, A> | null>\r\n\r\n  /**\r\n   * Determines the frequency of stability checks for all selectors.\r\n   * This setting overrides the global configuration for\r\n   * the `useSelector` stability check, allowing you to specify how often\r\n   * these checks should occur in development mode.\r\n   *\r\n   * @since 8.1.0\r\n   */\r\n  stabilityCheck?: DevModeCheckFrequency\r\n\r\n  /**\r\n   * Determines the frequency of identity function checks for all selectors.\r\n   * This setting overrides the global configuration for\r\n   * the `useSelector` identity function check, allowing you to specify how often\r\n   * these checks should occur in development mode.\r\n   *\r\n   * **Note**: Previously referred to as `noopCheck`.\r\n   *\r\n   * @since 9.0.0\r\n   */\r\n  identityFunctionCheck?: DevModeCheckFrequency\r\n\r\n  children: ReactNode\r\n}\r\n\r\nfunction Provider<A extends Action<string> = UnknownAction, S = unknown>({\r\n  store,\r\n  context,\r\n  children,\r\n  serverState,\r\n  stabilityCheck = 'once',\r\n  identityFunctionCheck = 'once',\r\n}: ProviderProps<A, S>) {\r\n  const contextValue = React.useMemo(() => {\r\n    const subscription = createSubscription(store)\r\n    return {\r\n      store,\r\n      subscription,\r\n      getServerState: serverState ? () => serverState : undefined,\r\n      stabilityCheck,\r\n      identityFunctionCheck,\r\n    }\r\n  }, [store, serverState, stabilityCheck, identityFunctionCheck])\r\n\r\n  const previousState = React.useMemo(() => store.getState(), [store])\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const { subscription } = contextValue\r\n    subscription.onStateChange = subscription.notifyNestedSubs\r\n    subscription.trySubscribe()\r\n\r\n    if (previousState !== store.getState()) {\r\n      subscription.notifyNestedSubs()\r\n    }\r\n    return () => {\r\n      subscription.tryUnsubscribe()\r\n      subscription.onStateChange = undefined\r\n    }\r\n  }, [contextValue, previousState])\r\n\r\n  const Context = context || ReactReduxContext\r\n\r\n  // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\r\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>\r\n}\r\n\r\nexport default Provider\r\n","import type { Context } from 'react'\r\nimport type { Action as BasicAction, UnknownAction, Store } from 'redux'\r\nimport type { ReactReduxContextValue } from '../components/Context'\r\nimport { ReactReduxContext } from '../components/Context'\r\nimport {\r\n  useReduxContext as useDefaultReduxContext,\r\n  createReduxContextHook,\r\n} from './useReduxContext'\r\n\r\n/**\r\n * Hook factory, which creates a `useStore` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useStore` hook bound to the specified context.\r\n */\r\nexport function createStoreHook<\r\n  S = unknown,\r\n  A extends BasicAction = UnknownAction\r\n  // @ts-ignore\r\n>(context?: Context<ReactReduxContextValue<S, A> | null> = ReactReduxContext) {\r\n  const useReduxContext =\r\n    // @ts-ignore\r\n    context === ReactReduxContext\r\n      ? useDefaultReduxContext\r\n      : // @ts-ignore\r\n        createReduxContextHook(context)\r\n  return function useStore<\r\n    State = S,\r\n    Action2 extends BasicAction = A\r\n    // @ts-ignore\r\n  >() {\r\n    const { store } = useReduxContext()\r\n    // @ts-ignore\r\n    return store as Store<State, Action2>\r\n  }\r\n}\r\n\r\n/**\r\n * A hook to access the redux store.\r\n *\r\n * @returns {any} the redux store\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useStore } from 'react-redux'\r\n *\r\n * export const ExampleComponent = () => {\r\n *   const store = useStore()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\r\nexport const useStore = /*#__PURE__*/ createStoreHook()\r\n","import type { Action, Dispatch, UnknownAction } from 'redux'\r\nimport type { Context } from 'react'\r\n\r\nimport type { ReactReduxContextValue } from '../components/Context'\r\nimport { ReactReduxContext } from '../components/Context'\r\nimport { useStore as useDefaultStore, createStoreHook } from './useStore'\r\n\r\n/**\r\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useDispatch` hook bound to the specified context.\r\n */\r\nexport function createDispatchHook<\r\n  S = unknown,\r\n  A extends Action<string> = UnknownAction\r\n  // @ts-ignore\r\n>(context?: Context<ReactReduxContextValue<S, A> | null> = ReactReduxContext) {\r\n  const useStore =\r\n    // @ts-ignore\r\n    context === ReactReduxContext ? useDefaultStore : createStoreHook(context)\r\n\r\n  return function useDispatch<\r\n    AppDispatch extends Dispatch<A> = Dispatch<A>\r\n  >(): AppDispatch {\r\n    const store = useStore()\r\n    // @ts-ignore\r\n    return store.dispatch\r\n  }\r\n}\r\n\r\n/**\r\n * A hook to access the redux `dispatch` function.\r\n *\r\n * @returns {any|function} redux store's `dispatch` function\r\n *\r\n * @example\r\n *\r\n * import React, { useCallback } from 'react'\r\n * import { useDispatch } from 'react-redux'\r\n *\r\n * export const CounterComponent = ({ value }) => {\r\n *   const dispatch = useDispatch()\r\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\r\n *   return (\r\n *     <div>\r\n *       <span>{value}</span>\r\n *       <button onClick={increaseCounter}>Increase counter</button>\r\n *     </div>\r\n *   )\r\n * }\r\n */\r\nexport const useDispatch = /*#__PURE__*/ createDispatchHook()\r\n","import Provider from './components/Provider'\r\nimport type { ProviderProps } from './components/Provider'\r\nimport connect from './components/connect'\r\nimport type {\r\n  Connect,\r\n  ConnectProps,\r\n  ConnectedProps,\r\n} from './components/connect'\r\nimport type {\r\n  SelectorFactory,\r\n  Selector,\r\n  MapStateToProps,\r\n  MapStateToPropsFactory,\r\n  MapStateToPropsParam,\r\n  MapDispatchToPropsFunction,\r\n  MapDispatchToProps,\r\n  MapDispatchToPropsFactory,\r\n  MapDispatchToPropsParam,\r\n  MapDispatchToPropsNonObject,\r\n  MergeProps,\r\n} from './connect/selectorFactory'\r\nimport { ReactReduxContext } from './components/Context'\r\nimport type { ReactReduxContextValue } from './components/Context'\r\n\r\nimport { useDispatch, createDispatchHook } from './hooks/useDispatch'\r\nimport { useSelector, createSelectorHook } from './hooks/useSelector'\r\nimport { useStore, createStoreHook } from './hooks/useStore'\r\n\r\nimport shallowEqual from './utils/shallowEqual'\r\nimport type { Subscription } from './utils/Subscription'\r\nimport { defaultNoopBatch } from './utils/batch'\r\n\r\nexport * from './types'\r\nexport type {\r\n  ProviderProps,\r\n  SelectorFactory,\r\n  Selector,\r\n  MapStateToProps,\r\n  MapStateToPropsFactory,\r\n  MapStateToPropsParam,\r\n  Connect,\r\n  ConnectProps,\r\n  ConnectedProps,\r\n  MapDispatchToPropsFunction,\r\n  MapDispatchToProps,\r\n  MapDispatchToPropsFactory,\r\n  MapDispatchToPropsParam,\r\n  MapDispatchToPropsNonObject,\r\n  MergeProps,\r\n  ReactReduxContextValue,\r\n  Subscription,\r\n}\r\n\r\n/**\r\n * @deprecated As of React 18, batching is enabled by default for ReactDOM and React Native.\r\n * This is now a no-op that immediately runs the callback.\r\n */\r\nconst batch = defaultNoopBatch\r\n\r\nexport {\r\n  Provider,\r\n  ReactReduxContext,\r\n  connect,\r\n  useDispatch,\r\n  createDispatchHook,\r\n  useSelector,\r\n  createSelectorHook,\r\n  useStore,\r\n  createStoreHook,\r\n  shallowEqual,\r\n  batch,\r\n}\r\n"]},"metadata":{},"sourceType":"module"}